{"ast":null,"code":"import _asyncToGenerator from \"/Users/carstenlawrenz/GIT/KTB3/windchill-mcp-server/angular-ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HttpHeaders } from '@angular/common/http';\nimport { firstValueFrom } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let McpService = /*#__PURE__*/(() => {\n  class McpService {\n    constructor(http) {\n      this.http = http;\n      this.baseUrl = '/api';\n    }\n    /**\n     * Get the list of available tools using MCP JSON-RPC 2.0 protocol\n     */\n    getToolsList() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const request = {\n          jsonrpc: '2.0',\n          id: _this.generateId(),\n          method: 'tools/list',\n          params: {}\n        };\n        try {\n          const response = yield Promise.race([firstValueFrom(_this.http.post(_this.baseUrl, request, {\n            headers: new HttpHeaders({\n              'Content-Type': 'application/json'\n            })\n          })), new Promise((_, reject) => setTimeout(() => reject(new Error('Request timeout')), 5000))]);\n          console.log('MCP protocol response:', response);\n          if (response.error) {\n            throw new Error(`MCP Error ${response.error.code}: ${response.error.message}`);\n          }\n          if (!response.result) {\n            console.warn('MCP response.result is undefined, falling back to direct HTTP');\n            throw new Error('Invalid MCP response: result is undefined');\n          }\n          return response.result;\n        } catch (error) {\n          // Fallback to direct HTTP request if MCP protocol fails\n          console.warn('MCP protocol failed, falling back to direct HTTP:', error.message);\n          return _this.getToolsListDirect();\n        }\n      })();\n    }\n    /**\n     * Fallback method to get tools list via direct HTTP request\n     */\n    getToolsListDirect() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          console.log('Attempting direct HTTP GET to /api/tools');\n          const response = yield Promise.race([firstValueFrom(_this2.http.get(`${_this2.baseUrl}/tools`)), new Promise((_, reject) => setTimeout(() => reject(new Error('Direct request timeout')), 5000))]);\n          console.log('Direct HTTP response:', response);\n          if (!response || !response.tools) {\n            throw new Error('Invalid response format from server');\n          }\n          return response;\n        } catch (error) {\n          console.error('Direct HTTP request failed:', error);\n          throw new Error(`Failed to load tools: ${error?.message || 'Server unreachable'}`);\n        }\n      })();\n    }\n    /**\n     * Execute a tool using MCP JSON-RPC 2.0 protocol\n     */\n    executeTool(toolName, parameters) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        console.log('MCP Service executeTool called:', {\n          toolName,\n          parameters\n        });\n        const request = {\n          jsonrpc: '2.0',\n          id: _this3.generateId(),\n          method: 'tools/call',\n          params: {\n            name: toolName,\n            arguments: parameters\n          }\n        };\n        console.log('Sending MCP request:', request);\n        try {\n          const response = yield Promise.race([firstValueFrom(_this3.http.post(_this3.baseUrl, request, {\n            headers: new HttpHeaders({\n              'Content-Type': 'application/json'\n            })\n          })), new Promise((_, reject) => setTimeout(() => reject(new Error('Tool execution timeout')), 15000))]);\n          console.log('MCP response received:', response);\n          if (response.error) {\n            throw new Error(`MCP Error ${response.error.code}: ${response.error.message}`);\n          }\n          return response.result;\n        } catch (error) {\n          // Fallback to direct HTTP request if MCP protocol fails\n          console.warn('MCP protocol failed, falling back to direct HTTP:', error.message);\n          return _this3.executeToolDirect(toolName, parameters);\n        }\n      })();\n    }\n    /**\n     * Fallback method to execute tool via direct HTTP request\n     */\n    executeToolDirect(toolName, parameters) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          console.log('Executing tool via direct HTTP:', {\n            toolName,\n            parameters\n          });\n          const response = yield Promise.race([firstValueFrom(_this4.http.post(`${_this4.baseUrl}/tools/${toolName}`, parameters, {\n            headers: new HttpHeaders({\n              'Content-Type': 'application/json'\n            })\n          })), new Promise((_, reject) => setTimeout(() => reject(new Error('Tool execution timeout')), 15000))]);\n          console.log('Direct HTTP response received:', response);\n          return response;\n        } catch (error) {\n          console.error('Direct HTTP execution failed:', error);\n          if (error?.status === 404) {\n            throw new Error(`Tool '${toolName}' not found on server`);\n          }\n          if (error?.status === 500) {\n            throw new Error(`Server error executing tool: ${error?.error?.message || error?.message}`);\n          }\n          throw new Error(`Failed to execute tool: ${error?.message || 'Unknown error'}`);\n        }\n      })();\n    }\n    /**\n     * Generate a unique request ID for JSON-RPC\n     */\n    generateId() {\n      return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    /**\n     * Get server health status\n     */\n    getServerHealth() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        return firstValueFrom(_this5.http.get(`${_this5.baseUrl}/health`));\n      })();\n    }\n    /**\n     * Get server information\n     */\n    getServerInfo() {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        return firstValueFrom(_this6.http.get(`${_this6.baseUrl}/`));\n      })();\n    }\n    static {\n      this.ɵfac = function McpService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || McpService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: McpService,\n        factory: McpService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return McpService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}