{"ast":null,"code":"import _asyncToGenerator from \"/Users/carstenlawrenz/GIT/KTB3/windchill-mcp-server/angular-ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HttpHeaders } from '@angular/common/http';\nimport { firstValueFrom } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class McpService {\n  constructor(http) {\n    this.http = http;\n    this.baseUrl = '/api';\n  }\n  /**\n   * Get the list of available tools using MCP JSON-RPC 2.0 protocol\n   */\n  getToolsList() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const request = {\n        jsonrpc: '2.0',\n        id: _this.generateId(),\n        method: 'tools/list',\n        params: {}\n      };\n      try {\n        const response = yield Promise.race([firstValueFrom(_this.http.post(_this.baseUrl, request, {\n          headers: new HttpHeaders({\n            'Content-Type': 'application/json'\n          })\n        })), new Promise((_, reject) => setTimeout(() => reject(new Error('Request timeout')), 5000))]);\n        console.log('MCP protocol response:', response);\n        if (response.error) {\n          throw new Error(`MCP Error ${response.error.code}: ${response.error.message}`);\n        }\n        if (!response.result) {\n          console.warn('MCP response.result is undefined, falling back to direct HTTP');\n          throw new Error('Invalid MCP response: result is undefined');\n        }\n        return response.result;\n      } catch (error) {\n        // Fallback to direct HTTP request if MCP protocol fails\n        console.warn('MCP protocol failed, falling back to direct HTTP:', error.message);\n        return _this.getToolsListDirect();\n      }\n    })();\n  }\n  /**\n   * Fallback method to get tools list via direct HTTP request\n   */\n  getToolsListDirect() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        console.log('Attempting direct HTTP GET to /api/tools');\n        const response = yield Promise.race([firstValueFrom(_this2.http.get(`${_this2.baseUrl}/tools`)), new Promise((_, reject) => setTimeout(() => reject(new Error('Direct request timeout')), 5000))]);\n        console.log('Direct HTTP response:', response);\n        if (!response || !response.tools) {\n          throw new Error('Invalid response format from server');\n        }\n        return response;\n      } catch (error) {\n        console.error('Direct HTTP request failed:', error);\n        throw new Error(`Failed to load tools: ${error?.message || 'Server unreachable'}`);\n      }\n    })();\n  }\n  /**\n   * Execute a tool using MCP JSON-RPC 2.0 protocol\n   */\n  executeTool(toolName, parameters) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      console.log('=== MCP Service executeTool START ===');\n      console.log('Tool:', toolName);\n      console.log('Parameters:', parameters);\n      console.log('Parameter types:', Object.entries(parameters).map(([k, v]) => ({\n        [k]: typeof v\n      })));\n      const request = {\n        jsonrpc: '2.0',\n        id: _this3.generateId(),\n        method: 'tools/call',\n        params: {\n          name: toolName,\n          arguments: parameters\n        }\n      };\n      console.log('MCP JSON-RPC request:', {\n        url: _this3.baseUrl,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: request\n      });\n      try {\n        const response = yield Promise.race([firstValueFrom(_this3.http.post(_this3.baseUrl, request, {\n          headers: new HttpHeaders({\n            'Content-Type': 'application/json'\n          })\n        })), new Promise((_, reject) => setTimeout(() => reject(new Error('Tool execution timeout')), 15000))]);\n        console.log('MCP response received:', {\n          id: response.id,\n          hasResult: !!response.result,\n          hasError: !!response.error,\n          resultType: typeof response.result\n        });\n        if (response.error) {\n          console.error('MCP error response:', response.error);\n          throw new Error(`MCP Error ${response.error.code}: ${response.error.message}`);\n        }\n        // Unwrap MCP JSON-RPC response content\n        if (response.result?.content && Array.isArray(response.result.content) && response.result.content.length > 0) {\n          const content = response.result.content[0];\n          if (content.type === 'text' && content.text) {\n            try {\n              // Parse the JSON string in the text field to get the actual result\n              const actualResult = JSON.parse(content.text);\n              console.log('=== MCP Service executeTool SUCCESS ===');\n              console.log('Unwrapped result type:', typeof actualResult);\n              return actualResult;\n            } catch (parseError) {\n              // If not valid JSON, return the text as-is\n              console.log('=== MCP Service executeTool SUCCESS (text response) ===');\n              return content.text;\n            }\n          }\n        }\n        console.log('=== MCP Service executeTool SUCCESS ===');\n        return response.result;\n      } catch (error) {\n        console.log('=== MCP protocol failed, trying direct HTTP ===');\n        console.log('Error details:', {\n          message: error.message,\n          status: error.status,\n          statusText: error.statusText,\n          url: error.url\n        });\n        // Fallback to direct HTTP request if MCP protocol fails\n        return _this3.executeToolDirect(toolName, parameters);\n      }\n    })();\n  }\n  /**\n   * Fallback method to execute tool via direct HTTP request\n   */\n  executeToolDirect(toolName, parameters) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        console.log('=== Direct HTTP fallback execution ===');\n        console.log('Tool:', toolName);\n        console.log('Parameters:', parameters);\n        console.log('Direct HTTP URL:', `${_this4.baseUrl}/tools/${toolName}`);\n        const response = yield Promise.race([firstValueFrom(_this4.http.post(`${_this4.baseUrl}/tools/${toolName}`, parameters, {\n          headers: new HttpHeaders({\n            'Content-Type': 'application/json'\n          })\n        })), new Promise((_, reject) => setTimeout(() => reject(new Error('Tool execution timeout')), 15000))]);\n        console.log('=== Direct HTTP response received ===');\n        console.log('Response status:', response?.status);\n        console.log('Response data type:', typeof response);\n        console.log('Response data:', response);\n        return response;\n      } catch (error) {\n        console.error('=== Direct HTTP execution failed ===');\n        console.error('Error details:', {\n          message: error.message,\n          status: error.status,\n          statusText: error.statusText,\n          url: error.url,\n          data: error.data || error.error\n        });\n        if (error?.status === 404) {\n          throw new Error(`Tool '${toolName}' not found on server`);\n        }\n        if (error?.status === 500) {\n          throw new Error(`Server error executing tool: ${error?.error?.message || error?.message}`);\n        }\n        throw new Error(`Failed to execute tool: ${error?.message || 'Unknown error'}`);\n      }\n    })();\n  }\n  /**\n   * Generate a unique request ID for JSON-RPC\n   */\n  generateId() {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  /**\n   * Get server health status\n   */\n  getServerHealth() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return firstValueFrom(_this5.http.get(`${_this5.baseUrl}/health`));\n    })();\n  }\n  /**\n   * Get server information\n   */\n  getServerInfo() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return firstValueFrom(_this6.http.get(`${_this6.baseUrl}/`));\n    })();\n  }\n  static {\n    this.ɵfac = function McpService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || McpService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: McpService,\n      factory: McpService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpHeaders","firstValueFrom","McpService","constructor","http","baseUrl","getToolsList","_this","_asyncToGenerator","request","jsonrpc","id","generateId","method","params","response","Promise","race","post","headers","_","reject","setTimeout","Error","console","log","error","code","message","result","warn","getToolsListDirect","_this2","get","tools","executeTool","toolName","parameters","_this3","Object","entries","map","k","v","name","arguments","url","body","hasResult","hasError","resultType","content","Array","isArray","length","type","text","actualResult","JSON","parse","parseError","status","statusText","executeToolDirect","_this4","data","Date","now","Math","random","toString","substr","getServerHealth","_this5","getServerInfo","_this6","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["/Users/carstenlawrenz/GIT/KTB3/windchill-mcp-server/angular-ui/src/app/services/mcp.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { firstValueFrom } from 'rxjs';\n\nexport interface McpRequest {\n  jsonrpc: '2.0';\n  id: string;\n  method: string;\n  params?: any;\n}\n\nexport interface McpResponse {\n  jsonrpc: '2.0';\n  id: string;\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n    data?: any;\n  };\n}\n\nexport interface ToolsListResponse {\n  tools: Array<{\n    name: string;\n    description: string;\n    inputSchema: any;\n  }>;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class McpService {\n  private baseUrl = '/api';\n\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get the list of available tools using MCP JSON-RPC 2.0 protocol\n   */\n  async getToolsList(): Promise<ToolsListResponse> {\n    const request: McpRequest = {\n      jsonrpc: '2.0',\n      id: this.generateId(),\n      method: 'tools/list',\n      params: {}\n    };\n\n    try {\n      const response = await Promise.race([\n        firstValueFrom(\n          this.http.post<McpResponse>(this.baseUrl, request, {\n            headers: new HttpHeaders({\n              'Content-Type': 'application/json'\n            })\n          })\n        ),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('Request timeout')), 5000)\n        )\n      ]) as McpResponse;\n\n      console.log('MCP protocol response:', response);\n\n      if (response.error) {\n        throw new Error(`MCP Error ${response.error.code}: ${response.error.message}`);\n      }\n\n      if (!response.result) {\n        console.warn('MCP response.result is undefined, falling back to direct HTTP');\n        throw new Error('Invalid MCP response: result is undefined');\n      }\n\n      return response.result;\n    } catch (error: any) {\n      // Fallback to direct HTTP request if MCP protocol fails\n      console.warn('MCP protocol failed, falling back to direct HTTP:', error.message);\n      return this.getToolsListDirect();\n    }\n  }\n\n  /**\n   * Fallback method to get tools list via direct HTTP request\n   */\n  private async getToolsListDirect(): Promise<ToolsListResponse> {\n    try {\n      console.log('Attempting direct HTTP GET to /api/tools');\n      const response = await Promise.race([\n        firstValueFrom(\n          this.http.get<ToolsListResponse>(`${this.baseUrl}/tools`)\n        ),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('Direct request timeout')), 5000)\n        )\n      ]) as ToolsListResponse;\n\n      console.log('Direct HTTP response:', response);\n\n      if (!response || !response.tools) {\n        throw new Error('Invalid response format from server');\n      }\n\n      return response;\n    } catch (error: any) {\n      console.error('Direct HTTP request failed:', error);\n      throw new Error(`Failed to load tools: ${error?.message || 'Server unreachable'}`);\n    }\n  }\n\n  /**\n   * Execute a tool using MCP JSON-RPC 2.0 protocol\n   */\n  async executeTool(toolName: string, parameters: any): Promise<any> {\n    console.log('=== MCP Service executeTool START ===');\n    console.log('Tool:', toolName);\n    console.log('Parameters:', parameters);\n    console.log('Parameter types:', Object.entries(parameters).map(([k, v]) => ({ [k]: typeof v })));\n\n    const request: McpRequest = {\n      jsonrpc: '2.0',\n      id: this.generateId(),\n      method: 'tools/call',\n      params: {\n        name: toolName,\n        arguments: parameters\n      }\n    };\n\n    console.log('MCP JSON-RPC request:', {\n      url: this.baseUrl,\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: request\n    });\n\n    try {\n      const response = await Promise.race([\n        firstValueFrom(\n          this.http.post<McpResponse>(this.baseUrl, request, {\n            headers: new HttpHeaders({\n              'Content-Type': 'application/json'\n            })\n          })\n        ),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('Tool execution timeout')), 15000)\n        )\n      ]) as McpResponse;\n\n      console.log('MCP response received:', {\n        id: response.id,\n        hasResult: !!response.result,\n        hasError: !!response.error,\n        resultType: typeof response.result\n      });\n\n      if (response.error) {\n        console.error('MCP error response:', response.error);\n        throw new Error(`MCP Error ${response.error.code}: ${response.error.message}`);\n      }\n\n      // Unwrap MCP JSON-RPC response content\n      if (response.result?.content && Array.isArray(response.result.content) && response.result.content.length > 0) {\n        const content = response.result.content[0];\n        if (content.type === 'text' && content.text) {\n          try {\n            // Parse the JSON string in the text field to get the actual result\n            const actualResult = JSON.parse(content.text);\n            console.log('=== MCP Service executeTool SUCCESS ===');\n            console.log('Unwrapped result type:', typeof actualResult);\n            return actualResult;\n          } catch (parseError) {\n            // If not valid JSON, return the text as-is\n            console.log('=== MCP Service executeTool SUCCESS (text response) ===');\n            return content.text;\n          }\n        }\n      }\n\n      console.log('=== MCP Service executeTool SUCCESS ===');\n      return response.result;\n    } catch (error: any) {\n      console.log('=== MCP protocol failed, trying direct HTTP ===');\n      console.log('Error details:', {\n        message: error.message,\n        status: error.status,\n        statusText: error.statusText,\n        url: error.url\n      });\n\n      // Fallback to direct HTTP request if MCP protocol fails\n      return this.executeToolDirect(toolName, parameters);\n    }\n  }\n\n  /**\n   * Fallback method to execute tool via direct HTTP request\n   */\n  private async executeToolDirect(toolName: string, parameters: any): Promise<any> {\n    try {\n      console.log('=== Direct HTTP fallback execution ===');\n      console.log('Tool:', toolName);\n      console.log('Parameters:', parameters);\n      console.log('Direct HTTP URL:', `${this.baseUrl}/tools/${toolName}`);\n\n      const response = await Promise.race([\n        firstValueFrom(\n          this.http.post<any>(`${this.baseUrl}/tools/${toolName}`, parameters, {\n            headers: new HttpHeaders({\n              'Content-Type': 'application/json'\n            })\n          })\n        ),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error('Tool execution timeout')), 15000)\n        )\n      ]) as any;\n\n      console.log('=== Direct HTTP response received ===');\n      console.log('Response status:', response?.status);\n      console.log('Response data type:', typeof response);\n      console.log('Response data:', response);\n\n      return response;\n    } catch (error: any) {\n      console.error('=== Direct HTTP execution failed ===');\n      console.error('Error details:', {\n        message: error.message,\n        status: error.status,\n        statusText: error.statusText,\n        url: error.url,\n        data: error.data || error.error\n      });\n\n      if (error?.status === 404) {\n        throw new Error(`Tool '${toolName}' not found on server`);\n      }\n      if (error?.status === 500) {\n        throw new Error(`Server error executing tool: ${error?.error?.message || error?.message}`);\n      }\n      throw new Error(`Failed to execute tool: ${error?.message || 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Generate a unique request ID for JSON-RPC\n   */\n  private generateId(): string {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Get server health status\n   */\n  async getServerHealth(): Promise<any> {\n    return firstValueFrom(\n      this.http.get(`${this.baseUrl}/health`)\n    );\n  }\n\n  /**\n   * Get server information\n   */\n  async getServerInfo(): Promise<any> {\n    return firstValueFrom(\n      this.http.get(`${this.baseUrl}/`)\n    );\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}